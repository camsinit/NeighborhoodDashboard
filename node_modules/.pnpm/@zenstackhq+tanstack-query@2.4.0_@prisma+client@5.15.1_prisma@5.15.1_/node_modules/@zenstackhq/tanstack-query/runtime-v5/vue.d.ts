import * as _tanstack_vue_query from '@tanstack/vue-query';
import { UseQueryOptions, UseInfiniteQueryOptions, InfiniteData, UseMutationOptions } from '@tanstack/vue-query';
import { ModelMeta } from '@zenstackhq/runtime/cross';
import { MaybeRefOrGetter, ComputedRef } from 'vue';
import { A as APIContext, F as FetchFn, a as ExtraQueryOptions, E as ExtraMutationOptions } from './common-CXlL7vTW.js';

declare const VueQueryContextKey = "zenstack-vue-query-context";
/**
 * Provide context for the generated TanStack Query hooks.
 */
declare function provideHooksContext(context: APIContext): void;
/**
 * Hooks context.
 */
declare function getHooksContext(): {
    fetch?: FetchFn;
    logging?: boolean;
    endpoint: string;
};
/**
 * Creates a vue-query query.
 *
 * @param model The name of the model under query.
 * @param url The request URL.
 * @param args The request args object, URL-encoded and appended as "?q=" parameter
 * @param options The vue-query options object
 * @param fetch The fetch function to use for sending the HTTP request
 * @returns useQuery hook
 */
declare function useModelQuery<TQueryFnData, TData, TError>(model: string, url: string, args?: MaybeRefOrGetter<unknown> | ComputedRef<unknown>, options?: MaybeRefOrGetter<Omit<UseQueryOptions<TQueryFnData, TError, TData>, 'queryKey'> & ExtraQueryOptions> | ComputedRef<Omit<UseQueryOptions<TQueryFnData, TError, TData>, 'queryKey'> & ExtraQueryOptions>, fetch?: FetchFn): _tanstack_vue_query.UseQueryReturnType<TData, TError>;
/**
 * Creates a vue-query infinite query.
 *
 * @param model The name of the model under query.
 * @param url The request URL.
 * @param args The initial request args object, URL-encoded and appended as "?q=" parameter
 * @param options The vue-query infinite query options object
 * @param fetch The fetch function to use for sending the HTTP request
 * @returns useInfiniteQuery hook
 */
declare function useInfiniteModelQuery<TQueryFnData, TData, TError>(model: string, url: string, args?: MaybeRefOrGetter<unknown> | ComputedRef<unknown>, options?: MaybeRefOrGetter<Omit<UseInfiniteQueryOptions<TQueryFnData, TError, InfiniteData<TData>>, 'queryKey' | 'initialPageParam'>> | ComputedRef<Omit<UseInfiniteQueryOptions<TQueryFnData, TError, InfiniteData<TData>>, 'queryKey' | 'initialPageParam'>>, fetch?: FetchFn): _tanstack_vue_query.UseInfiniteQueryReturnType<InfiniteData<TData>, TError>;
/**
 * Creates a mutation with vue-query.
 *
 * @param model The name of the model under mutation.
 * @param method The HTTP method.
 * @param modelMeta The model metadata.
 * @param url The request URL.
 * @param options The vue-query options.
 * @param fetch The fetch function to use for sending the HTTP request
 * @param checkReadBack Whether to check for read back errors and return undefined if found.
 * @returns useMutation hooks
 */
declare function useModelMutation<TArgs, TError, R = any, C extends boolean = boolean, Result = C extends true ? R | undefined : R>(model: string, method: 'POST' | 'PUT' | 'DELETE', url: string, modelMeta: ModelMeta, options?: MaybeRefOrGetter<Omit<UseMutationOptions<Result, TError, TArgs, unknown>, 'mutationFn'> & ExtraMutationOptions> | ComputedRef<Omit<UseMutationOptions<Result, TError, TArgs, unknown>, 'mutationFn'> & ExtraMutationOptions>, fetch?: FetchFn, checkReadBack?: C): _tanstack_vue_query.UseMutationReturnType<Result, TError, TArgs, unknown, Omit<_tanstack_vue_query.MutationObserverIdleResult<Result, TError, TArgs, unknown>, "mutate" | "reset"> | Omit<_tanstack_vue_query.MutationObserverLoadingResult<Result, TError, TArgs, unknown>, "mutate" | "reset"> | Omit<_tanstack_vue_query.MutationObserverErrorResult<Result, TError, TArgs, unknown>, "mutate" | "reset"> | Omit<_tanstack_vue_query.MutationObserverSuccessResult<Result, TError, TArgs, unknown>, "mutate" | "reset">>;

export { APIContext as RequestHandlerContext, VueQueryContextKey, getHooksContext, provideHooksContext, useInfiniteModelQuery, useModelMutation, useModelQuery };
