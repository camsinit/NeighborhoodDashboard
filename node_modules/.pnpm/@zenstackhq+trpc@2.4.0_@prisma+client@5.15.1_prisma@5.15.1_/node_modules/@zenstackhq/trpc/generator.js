"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generate = generate;
const sdk_1 = require("@zenstackhq/sdk");
const ast_1 = require("@zenstackhq/sdk/ast");
const prisma_1 = require("@zenstackhq/sdk/prisma");
const fs_1 = __importDefault(require("fs"));
const lower_case_first_1 = require("lower-case-first");
const path_1 = __importDefault(require("path"));
const ts_morph_1 = require("ts-morph");
const upper_case_first_1 = require("upper-case-first");
const _1 = require(".");
const helpers_1 = require("./helpers");
const project_1 = require("./project");
function generate(model, options, dmmf) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a;
        // resolve "generateModels" option
        const generateModels = (0, sdk_1.parseOptionAsStrings)(options, 'generateModels', _1.name);
        // resolve "generateModelActions" option
        const generateModelActions = (0, sdk_1.parseOptionAsStrings)(options, 'generateModelActions', _1.name);
        // resolve "generateClientHelpers" option
        const generateClientHelpers = (0, sdk_1.parseOptionAsStrings)(options, 'generateClientHelpers', _1.name);
        if (generateClientHelpers && !generateClientHelpers.every((v) => ['react', 'next'].includes(v))) {
            throw new sdk_1.PluginError(_1.name, `Option "generateClientHelpers" only support values "react" and "next"`);
        }
        if (options.zodSchemasImport && typeof options.zodSchemasImport !== 'string') {
            throw new sdk_1.PluginError(_1.name, `Option "zodSchemasImport" must be a string`);
        }
        let outDir = (0, sdk_1.requireOption)(options, 'output', _1.name);
        outDir = (0, sdk_1.resolvePath)(outDir, options);
        (0, sdk_1.ensureEmptyDir)(outDir);
        const prismaClientDmmf = dmmf;
        let modelOperations = prismaClientDmmf.mappings.modelOperations;
        if (generateModels) {
            modelOperations = modelOperations.filter((mo) => generateModels.includes(mo.model));
        }
        // TODO: remove this legacy code that deals with "@Gen.hide" comment syntax inherited
        // from original code
        const hiddenModels = [];
        (0, helpers_1.resolveModelsComments)(prismaClientDmmf.datamodel.models, hiddenModels);
        const zodSchemasImport = (_a = options.zodSchemasImport) !== null && _a !== void 0 ? _a : '@zenstackhq/runtime/zod';
        createAppRouter(outDir, modelOperations, hiddenModels, generateModelActions, generateClientHelpers, model, zodSchemasImport, options);
        createHelper(outDir);
        yield (0, sdk_1.saveProject)(project_1.project);
    });
}
function createAppRouter(outDir, modelOperations, hiddenModels, generateModelActions, generateClientHelpers, zmodel, zodSchemasImport, options) {
    const indexFile = path_1.default.resolve(outDir, 'routers', `index.ts`);
    const appRouter = project_1.project.createSourceFile(indexFile, undefined, {
        overwrite: true,
    });
    appRouter.addStatements('/* eslint-disable */');
    const prismaImport = (0, prisma_1.getPrismaClientImportSpec)(path_1.default.dirname(indexFile), options);
    appRouter.addImportDeclarations([
        {
            namedImports: [
                'unsetMarker',
                'AnyRouter',
                'AnyRootConfig',
                'CreateRouterInner',
                'Procedure',
                'ProcedureBuilder',
                'ProcedureParams',
                'ProcedureRouterRecord',
                'ProcedureType',
            ],
            isTypeOnly: true,
            moduleSpecifier: '@trpc/server',
        },
        {
            namedImports: ['PrismaClient'],
            isTypeOnly: true,
            moduleSpecifier: prismaImport,
        },
    ]);
    appRouter.addStatements(`

        export type BaseConfig = AnyRootConfig;

        export type RouterFactory<Config extends BaseConfig> = <
            ProcRouterRecord extends ProcedureRouterRecord
        >(
            procedures: ProcRouterRecord
        ) => CreateRouterInner<Config, ProcRouterRecord>;
            
        export type UnsetMarker = typeof unsetMarker;

        export type ProcBuilder<Config extends BaseConfig> = ProcedureBuilder<
            ProcedureParams<Config, any, any, any, UnsetMarker, UnsetMarker, any>
        >;

        export function db(ctx: any) {
            if (!ctx.prisma) {
                throw new Error('Missing "prisma" field in trpc context');
            }
            return ctx.prisma as PrismaClient;
        }
        
    `);
    const filteredModelOperations = modelOperations.filter((mo) => !hiddenModels.includes(mo.model));
    appRouter
        .addFunction({
        name: 'createRouter<Config extends BaseConfig>',
        parameters: [
            { name: 'router', type: 'RouterFactory<Config>' },
            { name: 'procedure', type: 'ProcBuilder<Config>' },
        ],
        isExported: true,
    })
        .setBodyText((writer) => {
        writer.write('return router(');
        writer.block(() => {
            for (const modelOperation of filteredModelOperations) {
                const { model } = modelOperation, operations = __rest(modelOperation, ["model"]);
                // "count" operation is missing from Prisma DMMF, add it here
                operations.count = `count${model}`;
                generateModelCreateRouter(project_1.project, model, operations, outDir, generateModelActions, generateClientHelpers, zodSchemasImport, options, zmodel);
                appRouter.addImportDeclaration({
                    defaultImport: `create${model}Router`,
                    moduleSpecifier: `./${model}.router`,
                });
                writer.writeLine(`${(0, lower_case_first_1.lowerCaseFirst)(model)}: create${model}Router(router, procedure),`);
            }
        });
        writer.write(');');
    });
    if (generateClientHelpers) {
        appRouter.addInterface({
            name: 'ClientType',
            typeParameters: ['AppRouter extends AnyRouter'],
            isExported: true,
            properties: filteredModelOperations.map(({ model }) => {
                appRouter.addImportDeclaration({
                    namedImports: [{ name: 'ClientType', alias: `${(0, upper_case_first_1.upperCaseFirst)(model)}ClientType` }],
                    moduleSpecifier: `./${model}.router`,
                });
                return {
                    name: (0, lower_case_first_1.lowerCaseFirst)(model),
                    type: `${(0, upper_case_first_1.upperCaseFirst)(model)}ClientType<AppRouter>`,
                };
            }),
        });
        createClientHelpers(outDir, generateClientHelpers);
    }
    appRouter.formatText();
}
function createClientHelpers(outputDir, generateClientHelpers) {
    const utils = project_1.project.createSourceFile(path_1.default.resolve(outputDir, 'client', `utils.ts`), undefined, {
        overwrite: true,
    });
    utils.replaceWithText(fs_1.default.readFileSync(path_1.default.join(__dirname, './res/client/utils.ts'), 'utf-8'));
    for (const client of generateClientHelpers) {
        switch (client) {
            case 'react': {
                const content = fs_1.default.readFileSync(path_1.default.join(__dirname, './res/client/react.ts'), 'utf-8');
                project_1.project.createSourceFile(path_1.default.resolve(outputDir, 'client', 'react.ts'), content, {
                    overwrite: true,
                });
                break;
            }
            case 'next': {
                const content = fs_1.default.readFileSync(path_1.default.join(__dirname, './res/client/next.ts'), 'utf-8');
                project_1.project.createSourceFile(path_1.default.resolve(outputDir, 'client', 'next.ts'), content, { overwrite: true });
                break;
            }
        }
    }
}
function generateModelCreateRouter(project, model, operations, outputDir, generateModelActions, generateClientHelpers, zodSchemasImport, options, zmodel) {
    const modelRouter = project.createSourceFile(path_1.default.resolve(outputDir, 'routers', `${model}.router.ts`), undefined, {
        overwrite: true,
    });
    modelRouter.addStatements('/* eslint-disable */');
    modelRouter.addImportDeclarations([
        {
            namedImports: ['type RouterFactory', 'type ProcBuilder', 'type BaseConfig', 'db'],
            moduleSpecifier: '.',
        },
    ]);
    (0, helpers_1.generateRouterSchemaImport)(modelRouter, zodSchemasImport);
    (0, helpers_1.generateHelperImport)(modelRouter);
    if (generateClientHelpers) {
        (0, helpers_1.generateRouterTypingImports)(modelRouter, options);
    }
    const createRouterFunc = modelRouter.addFunction({
        name: 'createRouter<Config extends BaseConfig>',
        parameters: [
            { name: 'router', type: 'RouterFactory<Config>' },
            { name: 'procedure', type: 'ProcBuilder<Config>' },
        ],
        isExported: true,
        isDefaultExport: true,
    });
    let routerTypingStructure = undefined;
    if (generateClientHelpers) {
        // generate an interface for precise Prisma-like typing for the router procedures
        // which will be used to correct tRPC's typing on the client side
        routerTypingStructure = {
            kind: ts_morph_1.StructureKind.Interface,
            name: 'ClientType',
            isExported: true,
            typeParameters: ['AppRouter extends AnyRouter', `Context = AppRouter['_def']['_config']['$types']['ctx']`],
            properties: [],
        };
    }
    const dataModel = zmodel.declarations.find((d) => (0, ast_1.isDataModel)(d) && d.name === model);
    if (!dataModel) {
        throw new Error(`Data model "${model}" not found`);
    }
    createRouterFunc.setBodyText((funcWriter) => {
        funcWriter.write('return router(');
        funcWriter.block(() => {
            var _a;
            for (const [opType, opNameWithModel] of Object.entries(operations)) {
                if ((0, sdk_1.isDelegateModel)(dataModel) && (opType.startsWith('create') || opType.startsWith('upsert'))) {
                    // delete models don't support create or upsert operations
                    continue;
                }
                const baseOpType = opType.replace('OrThrow', '');
                const inputType = (0, helpers_1.getInputSchemaByOpName)(baseOpType, model);
                const generateOpName = opType.replace(/One$/, '');
                if (opNameWithModel &&
                    inputType &&
                    (!generateModelActions || generateModelActions.includes(generateOpName))) {
                    if (generateOpName === 'createMany' && !(0, prisma_1.supportCreateMany)(zmodel)) {
                        continue;
                    }
                    (0, helpers_1.generateProcedure)(funcWriter, generateOpName, (0, upper_case_first_1.upperCaseFirst)(inputType), model, baseOpType);
                    if (routerTypingStructure) {
                        (_a = routerTypingStructure.properties) === null || _a === void 0 ? void 0 : _a.push({
                            kind: ts_morph_1.StructureKind.PropertySignature,
                            name: generateOpName,
                            type: (writer) => {
                                (0, helpers_1.generateRouterTyping)(writer, generateOpName, model, baseOpType);
                            },
                        });
                    }
                }
            }
        });
        funcWriter.write(');');
    });
    if (routerTypingStructure) {
        modelRouter.addInterface(routerTypingStructure);
    }
    modelRouter.formatText();
}
function createHelper(outDir) {
    const sf = project_1.project.createSourceFile(path_1.default.resolve(outDir, 'helper.ts'), undefined, {
        overwrite: true,
    });
    sf.addStatements('/* eslint-disable */');
    sf.addStatements(`import { TRPCError } from '@trpc/server';`);
    sf.addStatements(`import { isPrismaClientKnownRequestError } from '${sdk_1.RUNTIME_PACKAGE}';`);
    const checkMutate = sf.addFunction({
        name: 'checkMutate',
        typeParameters: [{ name: 'T' }],
        parameters: [
            {
                name: 'promise',
                type: 'Promise<T>',
            },
        ],
        isAsync: true,
        isExported: true,
        returnType: 'Promise<T | undefined>',
    });
    checkMutate.setBodyText(`try {
            return await promise;
        } catch (err: any) {
            if (isPrismaClientKnownRequestError(err)) {
                if (err.code === 'P2004') {
                    if (err.meta?.reason === '${sdk_1.CrudFailureReason.RESULT_NOT_READABLE}') {
                        // unable to readback data
                        return undefined;
                    } else {
                        // rejected by policy
                        throw new TRPCError({
                            code: 'FORBIDDEN',
                            message: err.message,
                            cause: err,
                        });
                    }
                } else {
                    // request error
                    throw new TRPCError({
                        code: 'BAD_REQUEST',
                        message: err.message,
                        cause: err,
                    });
                }
            } else {
                throw err;
            }
        }
    `);
    checkMutate.formatText();
    const checkRead = sf.addFunction({
        name: 'checkRead',
        typeParameters: [{ name: 'T' }],
        parameters: [
            {
                name: 'promise',
                type: 'Promise<T>',
            },
        ],
        isAsync: true,
        isExported: true,
        returnType: 'Promise<T>',
    });
    checkRead.setBodyText(`try {
            return await promise;
        } catch (err: any) {
            if (isPrismaClientKnownRequestError(err)) {
                if (err.code === 'P2004') {
                    // rejected by policy
                    throw new TRPCError({
                        code: 'FORBIDDEN',
                        message: err.message,
                        cause: err,
                    });
                } else if (err.code === 'P2025') {
                    // not found
                    throw new TRPCError({
                        code: 'NOT_FOUND',
                        message: err.message,
                        cause: err,
                    });
                } else {
                    // request error
                    throw new TRPCError({
                        code: 'BAD_REQUEST',
                        message: err.message,
                        cause: err,
                    })
                }
            } else {
                throw err;
            }
        }
    `);
    checkRead.formatText();
}
//# sourceMappingURL=generator.js.map